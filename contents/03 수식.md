# 03. 수식
## 3.1 산술 연산자
일반적으로 다른 프로그래밍에도 널리 쓰이는 산술 연산자가 사용된다. 

## 3.2 관계 연산자
루아의 관계 연산자는 다음과 같다. 결과는 항상 `true`또는 `false`이다.
- `<`, `>`
- `<=`, `>=`
- `==`
- `~=`: 서로 다른지 여부를 검사한다.

## 3.3 논리 연산자
**제어 구조와 마찬가지로 `false`와 `nil`만 거짓으로 취급하고 다른 모든 값은 참이다.**
- `and`: false일 경우에 첫 번째 인자를 반환하며, 그렇지 않으면 두 번째 인자를 반환한다.
- `or`: false일 경우 두 번째 인자 반환, 그렇지 않으면 첫 번째 인자 반환
- `not`

~~~Lua
print(4 and 5)      --> 5 (true)
print(nil and 13)   --> nil (false)
print(false and 13) --> false
print(4 or 5)       --> 4 (true)
print(false or 5)   --> 5 (false)
~~~

저자는 유용한 루아 구문으로 `x = x or v`가 있다고 한다. 다음과 같은 의미를 지닌다.
~~~Lua
if not x then   --> x에 값이 없으면
    x = v       --> v를 기본값으로 설정
end
~~~

또 다른 경우로는 `(a and b) or c`가 있다. C언어로 치환하면 다음과 같다. 
~~~C
a?b:c // a가 true라면 b실행, false라면 c실행
~~~

x와 y 중 큰 값을 선택하는 문장은 다음과 같이 구현한다.
~~~Lua
max = (x > y) and x or y
~~~
- x > y 가 true인 경우: and는 두 번째 수식인 x를 반환하고, or는 첫 번째 수식 값 x를 반환한다.
- x > y 가 false인 경우: and는 false를 반환하고, or는 두 번째 수식 값 y를 반환한다.

## 3.4 문자열 병합 연산자
루아는 문자열 병합 연사자를 `..`으로 표시한다. 연산자 인자 중 어느 하나라도 수치를 지정하면 루아는 이 수치를 문자열로 변환한다.

## 3.5 연산자 우선순위
모든 이항 연산자는 병합 연산자와 거듭 제곱 (`^`)을 제외하고 왼쪽을 우선으로 둔다.

|우선도|연산자|비고|
|--|--|--|
|1|`^`||
|2|`not`, `#`|단항 연산자|
|3|`*`, `/`, `%`||
|4|`+`, `-`||
|5|`..`||
|6|`<`, `>`, `<=`, `>=`, `~=`, `==`||
|7|`and`||
|8|`or`||

## 3.6 테이블 생성자
간단한 테이블 생성자나 기본적인 테이블은 생략하고, 레코드와 비슷한 형태를 구현하는 초기화 문법을 사용하는 예시를 보자.
~~~Lua
a = {x = 10, y = 20}
~~~
위 코드는 다음과 같다.
~~~Lua
a = {}
a.x = 10
a.y = 20
~~~

언제든지 테이블에서 필드를 추가하거나 제거할 수 있다.

~~~lua
w = {x = 25, y = 50, label = "console"} --> 호출을 사실상 w[x], w.x로 해야 한다.
w[1] = "another field"                  --> w[1]에 값을 할당한다.

x = {math.sin(0), math.sin(1), math.sin(2)}
x.f = w                                 --> w의 모든 값을 x.f에 할당

print(w["x"])   --> 25
print(w[1])     --> another field
print(x[2])     --> 0.8414709848079
print(x.f[1])   --> another field
print(x.f.x)    --> 25
~~~

루아가 생성자를 평가할 때 항상 새로운 테이블을 생성하고 초기화한다. 따라서 연결 목록을 구현하는 데도 테이블을 사용할 수 있다(거의 사용할 일이 없는 예제라고 한다).
~~~lua
list = nil
for line in io.lines() do
    list = {next = list, value = line}
end

local l = list
while l do
    print(l.value)
    l = l.next
end
~~~
표준 입력에서 문자열을 읽어서 연결 목록 안에 역순으로 저장한다. 그리고 목록을 모두 훑고 저장된 내용을 모두 출력한다. 목록 안의 노드는 각각 두 개의 필드를 가진 테이블이다.
- value: 읽어들인 문자열의 내용
- next: 다음 노드에 대한 참조

하나의 생성자 안에서 레코드 목록 형식 초기화를 섞어서 사용하는 것도 가능하다.
~~~Lua
polyline = {color="blue", thickness=2, npoints=4,
            {x = 0, y = 0},
            {x = -10, y = 0},
            {x = -10, y = 1},
            {x = 0, y = 1}
            }
~~~
`polyline[i]`의 구성요소는 다음과 같이 접근할 수 있다.
~~~Lua
print(polyline[2].x) --> -10 
print(polyline[4].y) --> 1
~~~

그리고 다음과 같은 제한적인 상황에서는 초기화가 되지 않는다.
- 음수 키
- 부적절한 식별자를 담고 있는 문자열 키

---
출처
[프로그래밍 루아](https://search.shopping.naver.com/book/catalog/32492196601?query=%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EB%A3%A8%EC%95%84&NaPm=ct%3Dlg0lm4tc%7Cci%3D4ff95860ae3926b4ecded18df1cd90c3f669c3f1%7Ctr%3Dboksl%7Csn%3D95694%7Chk%3D03a50a86d09e9d6f540477098e76363425b34610)